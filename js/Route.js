// Generated by CoffeeScript 1.12.4
var Promise, Type, coalesce, createRegex, emptyArray, isValid, matchAll, matchRegex, readBody, type, validateQuery, validateTypes, valido;

Promise = require("Promise");

isValid = require("isValid");

valido = require("valido");

Type = require("Type");

readBody = require("./utils/readBody");

emptyArray = [];

matchAll = /.*/g;

type = Type("Route");

type.defineValues({
  _regex: null,
  _authorize: null
});

type.defineMethods({
  match: function(pattern) {
    if (isValid(pattern, "regexp")) {
      pattern.params = emptyArray;
      this._regex = pattern;
    } else if (isValid(pattern, "string")) {
      this._regex = createRegex(pattern);
    } else {
      throw TypeError("Expected a String or RegExp!");
    }
  },
  authorize: function(authorize) {
    this._authorize = authorize;
  },
  _build: function(responder, method) {
    var authorize, regex, route;
    regex = this._regex || matchAll;
    route = this._wrapResponder(responder);
    if (authorize = this._authorize) {
      responder = route;
      route = function(req, res) {
        if (authorize(req) === false) {
          return Promise.resolve(403);
        }
        return responder(req, res);
      };
    }
    return function(req) {
      if (req.method !== method) {
        return;
      }
      if (matchRegex(req, regex)) {
        return route;
      }
    };
  },
  _wrapResponder: function(responder) {
    var bodyTypes, queryTypes;
    if (isValid(this.query, "object")) {
      queryTypes = this.query;
      Object.keys(queryTypes).forEach(function(key) {
        return queryTypes[key] = valido.get(queryTypes[key]);
      });
      return function(req, res) {
        return Promise["try"](function() {
          var error;
          if (error = validateQuery(req.query, queryTypes)) {
            return error;
          }
          return responder.call(req, req.query, res);
        });
      };
    }
    if (this.body === true) {
      return function(req, res) {
        return readBody(req).then(function() {
          if (!req.body) {
            return Error("Missing body");
          }
          return responder.call(req, req.body, res);
        });
      };
    }
    if (isValid(this.body, "object")) {
      bodyTypes = this.body;
      Object.keys(bodyTypes).forEach(function(key) {
        return bodyTypes[key] = valido.get(bodyTypes[key]);
      });
      return function(req, res) {
        return readBody(req).then(function() {
          if (!req.body) {
            return Error("Missing body");
          }
          return req.json(function(body) {
            var error;
            if (error = validateTypes(body, bodyTypes)) {
              return error;
            }
            return responder.call(req, body, res);
          });
        });
      };
    }
    return function(req, res) {
      return Promise["try"](function() {
        return responder.call(req, res);
      });
    };
  }
});

module.exports = type.build();

createRegex = function(pattern) {
  var match, paramRE, params, regex, source;
  paramRE = /:[^\/]+/gi;
  params = [];
  source = "^" + pattern + "$";
  while (match = paramRE.exec(pattern)) {
    params.push(match[0].slice(1));
    source = source.replace(match[0], "([^\/]+)");
  }
  regex = new RegExp(source, "g");
  regex.params = params;
  return regex;
};

matchRegex = function(req, regex) {
  var match;
  regex.lastIndex = 0;
  if (!(match = regex.exec(req.path))) {
    return false;
  }
  if (match.length === 1) {
    return true;
  }
  match.slice(1).forEach(function(value, index) {
    req.query[regex.params[index] || index] = value;
  });
  return true;
};

validateTypes = function(obj, types) {
  var error, key;
  for (key in types) {
    type = types[key];
    error = type.assert(obj[key]);
    if (error) {
      return error(key);
    }
  }
};

validateQuery = function(obj, types) {
  var error, key;
  for (key in types) {
    type = types[key];
    coalesce(obj, key, type.name);
    error = type.assert(obj[key]);
    if (error) {
      return error(key);
    }
  }
};

coalesce = function(obj, key, type) {
  var value;
  value = obj[key];
  switch (type) {
    case "number":
      value = parseInt(value);
      if (!isNaN(value)) {
        obj[key] = value;
      }
      break;
    case "boolean":
      if ((value === void 0) || (value === "false")) {
        obj[key] = false;
      } else if ((value === "") || (value === "true")) {
        obj[key] = true;
      }
  }
};
