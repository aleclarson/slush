// Generated by CoffeeScript 1.12.4
var Promise, Type, Validator, createRegex, emptyArray, isType, matchAll, matchRegex, readBody, stringToBoolean, stringToNumber, type, validateTypes;

Validator = require("Validator");

Promise = require("Promise");

isType = require("isType");

Type = require("Type");

readBody = require("./utils/readBody");

emptyArray = [];

matchAll = /.*/g;

type = Type("Route");

type.defineValues({
  _regex: null,
  _authorize: null
});

type.defineMethods({
  match: function(pattern) {
    if (isType(pattern, RegExp)) {
      pattern.params = emptyArray;
      this._regex = pattern;
    } else if (typeof pattern === "string") {
      this._regex = createRegex(pattern);
    } else {
      throw TypeError("Expected a String or RegExp!");
    }
  },
  authorize: function(authorize) {
    this._authorize = authorize;
  },
  _build: function(responder, method) {
    var authorize, regex, route;
    regex = this._regex || matchAll;
    route = this._wrapResponder(responder);
    if (authorize = this._authorize) {
      responder = route;
      route = function(req, res) {
        if (authorize(req) === false) {
          return Promise.resolve(403);
        }
        return responder(req, res);
      };
    }
    return function(req) {
      if (req.method !== method) {
        return;
      }
      if (matchRegex(req, regex)) {
        return route;
      }
    };
  },
  _wrapResponder: function(responder) {
    var bodyTypes, queryTypes;
    if (isType(this.query, Object)) {
      queryTypes = this.query;
      Object.keys(queryTypes).forEach(function(key) {
        type = queryTypes[key];
        if (type === Number) {
          queryTypes[key] = stringToNumber;
        } else if (type === Boolean) {
          queryTypes[key] = stringToBoolean;
        }
      });
      return function(req, res) {
        return Promise["try"](function() {
          var error;
          if (error = validateTypes(req.query, queryTypes)) {
            return error;
          }
          return responder.call(req, req.query, res);
        });
      };
    }
    if (this.body === true) {
      return function(req, res) {
        return readBody(req).then(function() {
          if (!req.body) {
            return Error("Missing body");
          }
          return responder.call(req, req.body, res);
        });
      };
    }
    if (isType(this.body, Object)) {
      bodyTypes = this.body;
      return function(req, res) {
        return readBody(req).then(function() {
          if (!req.body) {
            return Error("Missing body");
          }
          return req.json(function(body) {
            var error;
            if (error = validateTypes(body, bodyTypes)) {
              return error;
            }
            return responder.call(req, body, res);
          });
        });
      };
    }
    return function(req, res) {
      return Promise["try"](function() {
        return responder.call(req, res);
      });
    };
  }
});

module.exports = type.build();

stringToNumber = function(query, key) {
  var value;
  value = parseInt(query[key]);
  if (isNaN(value)) {
    return Error("Expected '" + key + "' to be a Number");
  }
  query[key] = value;
};

stringToBoolean = function(query, key) {
  var value;
  value = query[key];
  if ((value === "") || (value === "true")) {
    value = true;
  } else if ((value === void 0) || (value === "false")) {
    value = false;
  }
  if (isType(value, Boolean)) {
    query[key] = value;
    return;
  }
  return Error("Expected '" + key + "' to be a Boolean");
};

createRegex = function(pattern) {
  var match, paramRegex, params, regex, source;
  paramRegex = /\{[^\}]+\}/g;
  params = [];
  source = "^" + pattern + "$";
  while (match = paramRegex.exec(source)) {
    params.push(match[0].slice(1, -1));
    source = source.replace(match[0], "([^\/]+)");
  }
  regex = new RegExp(source, "g");
  regex.params = params;
  return regex;
};

matchRegex = function(req, regex) {
  var match;
  regex.lastIndex = 0;
  if (!(match = regex.exec(req.path))) {
    return false;
  }
  if (match.length === 1) {
    return true;
  }
  match.slice(1).forEach(function(value, index) {
    req.query[regex.params[index] || index] = value;
  });
  return true;
};

validateTypes = function(obj, types) {
  var error, key;
  for (key in types) {
    type = types[key];
    if (typeof type === "function") {
      if (!/[A-Z]/.test(type.name[0])) {
        if (error = type(obj, key)) {
          return error;
        }
      } else if (!isType(obj[key], type)) {
        return Error("Expected '" + key + "' to be a " + type.name);
      }
    } else if (type instanceof Validator) {
      if (error = type.assert(obj[key], key)) {
        return error;
      }
    }
  }
};
