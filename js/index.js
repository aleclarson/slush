// Generated by CoffeeScript 2.2.3
var App, Layer, Request, Response, assertValid, createServer, createTrustProxy, etag, getPort, now, onFinish, onRequest, onTimeout, optionTypes, qs, setDefaults, setProto, valido, wrapDefaults;

wrapDefaults = require("wrap-defaults");

assertValid = require("assertValid");

setProto = require("setProto");

valido = require("valido");

now = require("performance-now");

qs = require("querystring");

createServer = require("./utils/createServer");

Response = require("../response");

Request = require("../request");

Layer = require("./Layer");

createTrustProxy = require("./utils/createTrustProxy");

etag = require("./utils/etag");

optionTypes = valido({
  path: "string?",
  port: "number?",
  secure: "boolean?",
  getContext: "function?",
  maxHeaders: "number?",
  timeout: "number?",
  onError: "function?",
  onUnhandled: "function?"
});

setDefaults = wrapDefaults({
  secure: false,
  maxHeaders: 50,
  timeout: 0,
  onError: function(error, res) {
    res.status(500);
    return res.end();
  },
  onUnhandled: function(res) {
    res.status(404);
    return res.end();
  }
});

App = class App {
  constructor(opts) {
    assertValid(opts, optionTypes);
    setDefaults(opts);
    this.port = getPort(opts);
    this.settings = Object.create(null);
    // Default settings
    this.set("trust proxy", false);
    this.set("subdomain offset", 2);
    this._layer = new Layer;
    this._server = createServer(opts, onRequest.bind(this));
    this._timeout = opts.timeout;
    this._onError = opts.onError;
    this._onUnhandled = opts.onUnhandled;
    this;
  }

  get(name) {
    return this.settings[name];
  }

  set(name, value) {
    // Remain compatible with `express`
    if (arguments.length === 1) {
      return this.settings[name];
    }
    this.settings[name] = value;
    switch (name) {
      case "etag":
        this.set("etag fn", etag.compile(value));
        break;
      case "trust proxy":
        this.set("trust proxy fn", createTrustProxy(value));
    }
    return this;
  }

  use(fn) {
    this._layer.use(fn);
    return this;
  }

  pipe(fn) {
    this._layer.pipe(fn);
    return this;
  }

  drain(fn) {
    this._layer.drain(fn);
    return this;
  }

  on(id, fn) {
    this._server.on(id, fn);
    return this;
  }

  emit() {
    this._server.emit(...arguments);
    return this;
  }

  ready(fn) {
    if (this._server.listening) {
      fn();
    } else {
      this._server.once("listening", fn);
    }
    return this;
  }

  close(fn) {
    if (fn) {
      this._server.once("close", fn);
    }
    this._server.close();
    return this;
  }

  // For testing only.
  _send(req, res) {
    return onRequest.call(this, req, res);
  }

};

App.Layer = Layer;

module.exports = App;


// Helpers

getPort = function(opts) {
  var port;
  if (!(port = opts.port)) {
    if (!(port = parseInt(process.env.PORT))) {
      port = opts.secure ? 443 : 8000;
    }
    opts.port = port;
  }
  return port;
};

onRequest = async function(req, res) {
  var app, error, parts;
  app = this;
  req.startTime = now();
  parts = req.url.split("?");
  req.path = parts[0];
  req.query = qs.parse(parts[1]);
  setProto(req.query, Object.prototype);
  req.app = app;
  req.res = res;
  setProto(req, Request);
  res.app = app;
  res.req = req;
  setProto(res, Response);
  // The unhandled request handler.
  req.next = app._onUnhandled.bind(req, res);
  // Prevent long-running requests.
  if (app._timeout > 0) {
    req.setTimeout(onTimeout, app._timeout);
  }
  try {
    // Attempt to handle the request.
    await app._layer.try(req, res);
    // Wait for the response to finish.
    if (!res.finished) {
      await onFinish(res);
    }
    if (req.reading) {
      // Prevent DoS attacks using large POST bodies.
      req.destroy();
    }
    if (res.statusCode !== 408) {
      return app.emit("response", req, res);
    }
  } catch (error1) {
    error = error1;
    app.emit("requestError", error);
    app._onError(error, res);
    return app.emit("response", req, res);
  }
};

onFinish = function(res) {
  return new Promise(function(resolve, reject) {
    res.on("finish", resolve);
    return res.on("error", reject);
  });
};

onTimeout = function(req, res) {
  res.status(408);
  this.emit("response", req, res);
};
