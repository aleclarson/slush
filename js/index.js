// Generated by CoffeeScript 1.12.4
var Promise, __DEV__, assertType, assertTypes, compression, express, ip, log, now, onFinish, optionTypes, path, setProto, ssl;

compression = require("compression");

assertTypes = require("assertTypes");

assertType = require("assertType");

setProto = require("setProto");

Promise = require("Promise");

express = require("express");

path = require("path");

now = require("performance-now");

log = require("log");

ip = require("ip");

optionTypes = {
  port: Number.Maybe,
  secure: Boolean.Maybe,
  compress: Boolean.Maybe
};

__DEV__ = process.env.NODE_ENV !== "production";

module.exports = function(options) {
  var app, pipes, port, server;
  if (options == null) {
    options = {};
  }
  assertTypes(options, optionTypes);
  app = express();
  server = options.secure ? require("https").createServer(ssl(), app) : require("http").createServer(app);
  server.maxHeadersCount = 50;
  app.port = port = options.port || process.env.PORT || (options.secure ? 4443 : 8000);
  app.ready = (function() {
    var promise, protocol, ref, resolve, url;
    ref = Promise.defer(), promise = ref.promise, resolve = ref.resolve;
    server.listen(port, resolve);
    protocol = options.secure ? "https" : "http";
    url = protocol + "://" + ip.address() + ":" + port;
    return function(callback) {
      return promise.then(function() {
        return callback(url);
      });
    };
  })();
  if (options.compress) {
    app.use(compression());
  }
  pipes = [];
  app.pipe = function(pipe) {
    assertType(pipe, Function);
    pipes.push(pipe);
    return app;
  };
  app.context = {};
  app.createContext = function() {
    return {};
  };
  app.use(function(req, res) {
    var context, index, measure, next, resolve, startTime;
    context = app.createContext(req, res);
    setProto(context, app.context);
    index = -1;
    measure = Function.prototype;
    if (__DEV__) {
      startTime = now();
      measure = function() {
        var status;
        log.moat(0);
        status = res.statusCode;
        if (status === 200) {
          log.green(status + " ");
        } else {
          log.red(status + " ");
        }
        log.white(req.method + " " + req.path + " ");
        log.gray((now() - startTime).toFixed(3) + "ms");
        log.moat(0);
      };
    }
    next = function() {
      var result;
      if (++index === pipes.length) {
        res.status(404);
        res.setHeader("Content-Type", "application/json");
        res.send({
          error: "Nothing exists here. Sorry!"
        });
        return;
      }
      result = pipes[index].call(context, req, res);
      if (result && typeof result.then === "function") {
        return result.then(resolve);
      } else {
        return resolve(result);
      }
    };
    resolve = function(result) {
      if (res.headersSent) {
        return;
      }
      if (!result) {
        return next();
      }
      if (typeof result === "number") {
        res.status(result);
        return res.end();
      }
      res.setHeader("Content-Type", "application/json");
      if (result.constructor === Object) {
        return res.send(result);
      }
      if (result instanceof Error) {
        if (res.statusCode === 200) {
          res.status(400);
        }
        return res.send({
          error: result.message
        });
      }
      throw Error("Invalid return type: " + result.constructor);
    };
    return Promise["try"](next).then(function() {
      if (!res.finished) {
        return onFinish(res);
      }
    }).then(function() {
      if (req.reading) {
        req.destroy();
      }
      return measure();
    }).fail(function(error) {
      log.moat(1);
      log.white(error.stack);
      log.moat(1);
      res.status(500);
      res.send({
        error: "Something went wrong on our end. Sorry!"
      });
      return measure();
    });
  });
  return app;
};

ssl = function() {
  var cert, fs, key;
  fs = require("fs");
  key = fs.readFileSync(path.resolve("ssl.key"), "utf8");
  cert = fs.readFileSync(path.resolve("ssl.crt"), "utf8");
  return {
    key: key,
    cert: cert
  };
};

onFinish = function(res) {
  var deferred;
  deferred = Promise.defer();
  res.on("finish", deferred.resolve);
  res.on("error", deferred.reject);
  return deferred.promise;
};
