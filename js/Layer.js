// Generated by CoffeeScript 1.12.7
var Promise, Type, assertValid, hookOnce, isValid, type;

assertValid = require("assertValid");

Promise = require("Promise");

isValid = require("isValid");

Type = require("Type");

type = Type("Layer");

type.defineValues(function() {
  return {
    _pipes: [],
    _drains: []
  };
});

type.defineMethods({
  use: function(fn) {
    assertValid(fn, "function");
    this._pipes.push(function(req, res) {
      var context;
      context = this;
      return new Promise(function(resolve) {
        hookOnce(req, "next", resolve);
        return fn.call(context, req, res, req.next);
      });
    });
  },
  pipe: function(fn) {
    assertValid(fn, "function");
    this._pipes.push(fn);
  },
  drain: function(fn) {
    assertValid(fn, "function");
    this._drains.push(fn);
  },
  "try": function(req, res) {
    var context, done, drain, drains, index, pipes, resolve;
    done = req.next;
    pipes = this._pipes;
    drains = this._drains;
    context = {};
    index = -1;
    req.next = function() {
      var result;
      if (++index === pipes.length) {
        return done();
      }
      result = pipes[index].call(context, req, res);
      if (result && isValid(result.then, "function")) {
        return result.then(resolve);
      } else {
        return resolve(result);
      }
    };
    resolve = function(result) {
      if (res.headersSent) {
        return;
      }
      if (!result) {
        return req.next();
      }
      if (result.constructor === Object) {
        return res.send(result);
      }
      if (isValid(result, "string")) {
        return res.send(result);
      }
      if (isValid(result, "number")) {
        res.set("Content-Length", 0);
        res.status(result);
        return res.end();
      }
      if (isValid(result, "error")) {
        if (res.statusCode < 300) {
          res.status(400);
        }
        return res.send({
          error: result.message
        });
      }
      if (Array.isArray(result)) {
        throw Error("Array responses are insecure");
      }
      throw Error("Invalid return type: " + result.constructor);
    };
    if (!drains.length) {
      return Promise["try"](req.next);
    }
    drain = function() {
      var fn, i, len;
      for (i = 0, len = drains.length; i < len; i++) {
        fn = drains[i];
        fn(req, res);
      }
    };
    return Promise["try"](req.next).then(drain, drain);
  }
});

module.exports = type.build();

hookOnce = function(obj, key, hook) {
  var orig;
  orig = obj[key];
  obj[key] = function() {
    obj[key] = orig;
    return hook();
  };
};
