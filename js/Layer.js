// Generated by CoffeeScript 1.12.4
var Promise, Type, assertType, emptyFunction, hookOnce, type;

emptyFunction = require("emptyFunction");

assertType = require("assertType");

Promise = require("Promise");

Type = require("Type");

type = Type("Layer");

type.defineValues(function() {
  return {
    _pipes: [],
    _drains: []
  };
});

type.defineMethods({
  use: function(fn) {
    assertType(fn, Function);
    this._pipes.push(function(req, res) {
      var context;
      context = this;
      return new Promise(function(resolve) {
        hookOnce(req, "next", resolve);
        return fn.call(context, req, res, req.next);
      });
    });
  },
  pipe: function(fn) {
    assertType(fn, Function);
    this._pipes.push(fn);
  },
  drain: function(fn) {
    assertType(fn, Function);
    this._drains.push(fn);
  },
  "try": function(req, res) {
    var context, done, drain, drains, index, pipes, resolve;
    done = req.next;
    pipes = this._pipes;
    drains = this._drains;
    context = {};
    index = -1;
    req.next = function() {
      var result;
      if (++index === pipes.length) {
        return done();
      }
      result = pipes[index].call(context, req, res);
      if (result && typeof result.then === "function") {
        return result.then(resolve);
      } else {
        return resolve(result);
      }
    };
    resolve = function(result) {
      if (res.headersSent) {
        return;
      }
      if (!result) {
        return req.next();
      }
      if (typeof result === "number") {
        res.status(result);
        return res.end();
      }
      if (result.constructor === Object) {
        return res.send(result);
      }
      if (result instanceof Error) {
        if (res.statusCode === 200) {
          res.status(400);
        }
        return res.send({
          error: result.message
        });
      }
      throw Error("Invalid return type: " + result.constructor);
    };
    if (!drains.length) {
      return Promise["try"](req.next);
    }
    drain = function() {
      var fn, i, len;
      for (i = 0, len = drains.length; i < len; i++) {
        fn = drains[i];
        fn(req, res);
      }
    };
    return Promise["try"](req.next).then(drain, drain);
  }
});

module.exports = type.build();

hookOnce = function(obj, key, hook) {
  var orig;
  orig = obj[key];
  obj[key] = function() {
    obj[key] = orig;
    return hook();
  };
};
